### 一、浏览器渲染过程

1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树
2. 将DOM树和CSSOM树结合，生成渲染树(Render Tree)
3. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
4. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. Display:将像素发送给GPU，展示在页面上。

### 二、回流（重排）

在构造渲染树时，我们已经将可见DOM节点以及它对应的样式结合起来，但是还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。

**回流——计算节点在设备视口内的确切位置和大小。**

### 三、重绘

最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。

**重绘——将渲染树的每个节点转换为屏幕上的实际像素。**

### 四、何时触发回流重绘

回流：

- 添加或删除可见的DOM元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
- 页面一开始渲染的时候（这肯定避免不了）
- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

**注意：回流一定会触发重绘，而重绘不一定会回流**

### 五、减少回流和重绘

1. 分离读写操作（现代浏览器的渲染队列的机制）

- 现代浏览器中默认增加了“渲染队列的机制”，以此来减少DOM的回流和重绘，遇到一行修改样式的代码，先放到渲染队列中，继续看 **下面一行代码** 是否还为修改样式的，如果是继续增加到渲染队列中...直到下面的代码不再是修改样式的，而是获取样式的代码！此时不再向渲染队列中增加，把之前渲染队列中要修改的样式一次性渲染到页面中，引发一次DOM的回流和重绘。

  ```js
  // 三次回流和重绘
  box.style.width = '200px';
  console.log(box.style.width); //=>中断渲染队列，立即渲染一次，引发一次DOM回流和重绘  200px
  box.style.height = '200px'; 
  console.log(box.offsetHeight);
  box.style.margin = '20px'; 
  
  // 一次回流重绘
  box.style.width = '200px';
  box.style.height = '200px';
  box.style.margin = '20px';
  console.log(box.style.width);
  console.log(box.offsetHeight); 
  ```

2. 元素批量修改

   临时创建的一个存放文档的容器，我们可以把新创建的LI，存放到容器中，当所有的LI都存储完，我们统一把容器中的内容增加到页面中（只触发一次回流）