### 前言、基础概念：

- javascript是**单线程语言**

  > 在浏览器中一个页面永远只有一个线程在执行js脚本代码（在不主动开启新线程的情况下）。

- javascript是单线程语言,但是代码解析却十分的快速，不会发生解析阻塞。

  > javascript是异步执行的，通过**事件循环（Event Loop）**的方式实现。

- js引擎执行过程分为三个阶段：

1. **语法分析**
2. **预编译阶段**
3. **执行阶段**

注：浏览器首先按顺序加载由`<script>`标签分割的js代码块，加载js代码块完毕后，立刻进入以上三个阶段，然后再按顺序查找下一个代码块，再继续执行以上三个阶段，无论是**外部脚本文件**（不异步加载）还是**内部脚本代码块**，都是一样的原理，并且都在同一个全局作用域中。

### 1、语法分析

js脚本代码块加载完毕后，会首先进入语法分析阶段。该阶段主要作用是：

> 分析该js脚本代码块的语法是否正确，如果出现不正确，则向外抛出一个**语法错误（SyntaxError）**，停止该js代码块的执行，然后继续查找并加载下一个代码块；如果语法正确，则进入预编译阶段

### 2、预编译阶段

js代码块通过语法分析阶段后，语法正确则进入预编译阶段。在分析预编译阶段之前，我们先了解一下js的**运行环境**，运行环境主要有三种：

- **全局环境**（JS代码加载完毕后，进入代码预编译即进入全局环境）
- **函数环境**（函数调用执行时，进入该函数环境，不同的函数则函数环境不同）
- **eval**（不建议使用，会有安全，性能等问题）

每进入一个不同的运行环境都会创建一个相应的**执行上下文（Execution Context）**，那么在一段JS程序中一般都会创建多个执行上下文，js引擎会以栈的方式对这些执行上下文进行处理，形成**函数调用栈（call stack）**，栈底永远是全局执行上下文（Global Execution Context），栈顶则永远是当前执行上下文。

#### 函数调用栈

> 函数调用栈就是使用栈存取的方式进行管理运行环境，特点是**先进后出，后进先出**。

我们分析下段简单的JS脚本代码来理解函数调用栈：

```
function bar() {
    var B_context = "Bar EC";

    function foo() {
        var f_context = "foo EC";
    }

    foo()
}

bar()
```

1. 首先进入全局环境，创建全局执行上下文（Global Execution Context），推入stack栈中
2. 调用bar函数，进入bar函数运行环境，创建bar函数执行上下文（bar Execution Context），推入stack栈中
3. 在bar函数内部调用foo函数，则再进入foo函数运行环境，创建foo函数执行上下文（foo Execution Context），推入stack栈中
4. 此刻栈底是全局执行上下文（Global Execution Context），栈顶是foo函数执行上下文（foo Execution Context），如上图，由于foo函数内部没有再调用其他函数，那么则开始出栈
5. foo函数执行完毕后，栈顶foo函数执行上下文（foo Execution Context）首先出栈
6. bar函数执行完毕，bar函数执行上下文（bar Execution Context）出栈
7. Global Execution Context则在浏览器或者该标签页关闭时出栈。

注：不同的运行环境执行都会进入代码预编译和执行两个阶段，语法分析则在代码块加载完毕时统一检验语法

#### 创建执行上下文

执行上下文可理解为当前的执行环境，与该运行环境相对应。创建执行上下文的过程中，主要做了以下三件事件：

1. **创建变量对象（Variable Object）**
2. **建立作用域链（Scope Chain）**
3. **确定this的指向**

#### 创建变量对象

创建变量对象主要经过以下几个过程：

1. 创建**arguments对象**，检查当前上下文中的参数，建立该对象的属性与属性值，仅在函数环境(非箭头函数)中进行，全局环境没有此过程
2. 检查当前上下文的**函数声明**，按代码顺序查找，将找到的函数提前声明，如果当前上下文的变量对象没有该函数名属性，则在该变量对象以函数名建立一个属性，属性值则为指向该函数所在堆内存地址的引用，如果存在，则会被新的引用覆盖。
3. 检查当前上下文的**变量声明**，按代码顺序查找，将找到的变量提前声明，如果当前上下文的变量对象没有该变量名属性，则在该变量对象以变量名建立一个属性，属性值为**undefined**；如果存在，则忽略该变量声明

注：在全局环境中，window对象就是全局执行上下文的变量对象，所有的变量和函数都是window对象的属性方法。

所以函数声明提前和变量声明提升是在创建变量对象中进行的，且函数声明优先级高于变量声明。

我们分析一段简单的代码，帮助我们理解该过程，如下：

```
function fun(a, b) {
    var num = 1;

    function test() {

        console.log(num)

    }
}

fun(2, 3)
```



这里我们在全局环境调用fun函数，创建fun执行上下文，这里为了方便大家理解，暂时不讲解作用域链以及this指向，如下：

```
funEC = {
    //变量对象
    VO: {
        //arguments对象
        arguments: {
            a: undefined,
            b: undefined,
            length: 2
        },

        //test函数
        test: <test reference>, 

        //num变量
        num: undefined
    },

    //作用域链
    scopeChain:[],

    //this指向
    this: window
}
```

- funEC表示fun函数的执行上下文（fun Execution Context简写为funEC）
- funE的变量对象中arguments属性，上面的写法仅为了方便大家理解，但是在浏览器中展示是以类数组的方式展示的
- `<test reference>`表示test函数在堆内存地址的引用

注：创建变量对象发生在预编译阶段，但尚未进入执行阶段，该变量对象都是不能访问的，因为此时的变量对象中的变量属性尚未赋值，值仍为undefined，只有进入执行阶段，变量对象中的变量属性进行赋值后，变量对象（Variable Object）转为活动对象（Active Object）后，才能进行访问，这个过程就是**VO –> AO**过程。

#### 建立作用域链

**作用域链由当前执行环境的变量对象（未进入执行阶段前）与上层环境的一系列活动对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。**

理清作用域链可以帮助我们理解js很多问题包括闭包问题等，下面我们结合一个简单的例子来理解作用域链，如下：

```
var num = 30;

function test() {
    var a = 10;

    function innerTest() {
        var b = 20;

        return a + b
    }

    innerTest()
}

test()
```



在上面的例子中，当执行到调用innerTest函数，进入innerTest函数环境。全局执行上下文和test函数执行上下文已进入执行阶段，innerTest函数执行上下文在预编译阶段创建变量对象，所以他们的活动对象和变量对象分别是AO(global)，AO(test)和VO(innerTest)，而innerTest的作用域链由当前执行环境的变量对象（未进入执行阶段前）与上层环境的一系列活动对象组成，如下：

```
innerTestEC = {

    //变量对象
    VO: {b: undefined}, 

    //作用域链
    scopeChain: [VO(innerTest), AO(test), AO(global)],  
    
    //this指向
    this: window
}
```

我们这里直接使用数组表示作用域链，作用域链的活动对象或变量对象可以直接理解为作用域。

- 作用域链的第一项永远是当前作用域（当前上下文的变量对象或活动对象）；

- 最后一项永远是全局作用域（全局执行上下文的活动对象）；

- 作用域链保证了变量和函数的有序访问，查找方式是沿着作用域链从左至右查找变量或函数，找到则会停止查找，找不到则一直查找到全局作用域，再找不到则会抛出引用错误。

  

闭包：

1. **在函数内部定义新函数**
2. **新函数访问外层函数的局部变量，即访问外层函数环境的活动对象属性**
3. **新函数执行，创建新的函数执行上下文，外层函数即为闭包**

#### 确定this指向

在全局环境下，全局执行上下文中变量对象的this属性指向为window；函数环境下的this指向却较为灵活，需根据执行环境和执行方法确定，需要举大量的典型例子概括，本文先不做分析。

### 3、执行阶段

> js是单线程的，为了避免代码解析阻塞使用了异步执行，那么它的异步执行机制是怎么样的？

通过事件循环（Event Loop），理解了事件循环的原理就理解了js的异步执行机制，本文主要介绍。

> js是单线程的，那么是否代表参与js执行过程的线程就只有一个？

不是的，会有四个线程参与该过程，但是永远只有JS引擎线程在执行JS脚本程序，其他的三个线程只协助，不参与代码解析与执行。参与js执行过程的线程分别是：

- **JS引擎线程**： 也称为JS内核，负责解析执行Javascript脚本程序的主线程（例如V8引擎）
- **事件触发线程**： 归属于浏览器内核进程，不受JS引擎线程控制。主要用于控制事件（例如鼠标，键盘等事件），当该事件被触发时候，事件触发线程就会把该事件的处理函数推进**事件队列**，等待JS引擎线程执行

- **定时器触发线程**：主要控制计时器setInterval和延时器setTimeout，用于定时器的计时，计时完毕，满足定时器的触发条件，则将定时器的处理函数推进事件队列中，等待JS引擎线程执行。
  注：W3C在HTML标准中规定setTimeout低于4ms的时间间隔算为4ms。
- **HTTP异步请求线程**：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。
  注：浏览器对通一域名请求的并发连接数是有限制的，Chrome和Firefox限制数为6个，ie8则为10个。

总结：永远只有JS引擎线程在执行JS脚本程序，其他三个线程只负责将满足触发条件的处理函数推进事件队列，等待JS引擎线程执行。



1. 宏任务（macro-task），宏任务又按执行顺序分为同步任务和异步任务

   - 同步任务

     ```
     console.log('script start');
     
     console.log('script end');
     ```

   - 异步任务

     ```
     setTimeout(function() {
       console.log('setTimeout');
     }, 0);
     ```

2. 微任务（micro-task）

   ```
   Promise.resolve().then(function() {
     console.log('promise1');
   }).then(function() {
     console.log('promise2');
   });
   ```

在JS引擎执行过程中，进入执行阶段后，代码的执行顺序如下：

```
宏任务(同步任务) --> 微任务 --> 宏任务(异步任务)
```

进入ES6或Node环境中，JS的任务分为两种，分别是**宏任务（macro-task）**和**微任务（micro-task）**，在最新的ECMAScript中，微任务称为jobs，宏任务称为task，他们的执行顺序如上。可能很多人对上面的分析并不理解，那么我们接下来继续对上面例子进行详细分析。

### 宏任务

宏任务（macro-task）可分为**同步任务**和**异步任务**：

- 同步任务指的是在JS引擎主线程上按顺序执行的任务，只有前一个任务执行完毕后，才能执行后一个任务，形成一个执行栈（函数调用栈）。
- 异步任务指的是不直接进入JS引擎主线程，而是满足触发条件时，相关的线程将该异步任务推进**任务队列(task queue)**，等待JS引擎主线程上的任务执行完毕，空闲时读取执行的任务，例如异步Ajax，DOM事件，setTimeout等。

理解宏任务中同步任务和异步任务的执行顺序，那么就相当于理解了JS异步执行机制–**事件循环（Event Loop）**。

#### 事件循环

事件循环可以理解成由三部分组成，分别是：

- **主线程执行栈**
- **异步任务等待触发**
- **任务队列**

**任务队列(task queue)就是以队列的数据结构对事件任务进行管理，特点是先进先出，后进后出**。

在JS引擎主线程执行过程中：

- 首先执行宏任务的同步任务，在主线程上形成一个**执行栈**，可理解为函数调用栈；
- 当执行栈中的函数调用到一些异步执行的API（例如异步Ajax，DOM事件，setTimeout等API），则会开启对应的线程（Http异步请求线程，事件触发线程和定时器触发线程）进行监控和控制
- 当异步任务的事件满足触发条件时，对应的线程则会把该事件的处理函数推进**任务队列(task queue)**中，等待主线程读取执行
- 当JS引擎主线程上的任务执行完毕，则会读取任务队列中的事件，将任务队列中的事件任务推进主线程中，按任务队列顺序执行
- 当JS引擎主线程上的任务执行完毕后，则会再次读取任务队列中的事件任务，如此循环，这就是事件循环（Event Loop）的过程

### 微任务

微任务是在es6和node环境中出现的一个任务类型，如果不考虑es6和node环境的话，我们只需要理解宏任务事件循环的执行过程就已经足够了，但是到了es6和node环境，我们就需要理解微任务的执行顺序了。
**微任务（micro-task）的API主要有:Promise， process.nextTick**

在宏任务中执行的任务有两种，分别是**同步任务**和**异步任务**，因为异步任务会在满足触发条件时才会推进任务队列（task queue），然后等待主线程上的任务执行完毕，再读取任务队列中的任务事件，最后推进主线程执行，所以这里将异步任务即任务队列看作是新的宏任务。执行的过程如上图所示：

1. 执行宏任务中**同步任务**，执行结束；
2. 检查是否存在可执行的**微任务**，有的话执行所有微任务，然后读取任务队列的任务事件，推进主线程形成新的宏任务；没有的话则读取任务队列的任务事件，推进主线程形成新的宏任务
3. 执行**新宏任务**的事件任务，再检查是否存在可执行的微任务，如此不断的重复循环