### 前言

1. 什么是`算法`

算法是一组完成任务的指令。任何代码片段都可以视为算法。

### 二分查找

#### 理解：

如果要在一个电话簿中查找名字为K打头的人，我们其实可以不从头开始翻，而是可以直接从中间开始，因为我们都知道k打头的名字在电话簿的中间。

#### 概念：

二分查找是一种算法，其输入是一个有序的元素列表。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null。

### 大O表示法

大O表示法指出了算法有多快。让你能够比较操作数，它指出了算法运行时间的增速。指出了最糟糕情况下的运行时间。

谈论的`算法的速度`是随着输入的增加，其运行时间将以什么样的速度增加。

#### 常见的大O运行时间

- O(log n)，也叫对数时间，这样的算法包括二分查找。
- O(n)，也叫线性时间，这样的算法包括简单查找。
- O(n * log n)，包括快速排序——一种速度较快的排序算法。
- O(n<sup>2</sup>)，包括选择排序——一种速度较慢的排序算法。
- O(n!)，旅行商问题——一种非常慢的算法。

### 数组数据结构

#### 特点：

​		数据在内存中是相连的，如果有新数据进入，原先预留的位置足够时可以直接添加数据，但是原先分配的内存不够时只能转移数据，要求分配个更大的数据。而且原先预留的位置有可能根本用不上，导致内存浪费。

#### 优势：

​		需要随机读取元素时，数组效率很高。

#### 劣势：

​		插入数据时，效率很低。

#### 访问方式：

​		随机访问、顺序访问

### 链表数据结构

#### 特点：

​		数据可以存储在内存的任何地方，链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。

#### 优势：

​		插入元素方便。

​		需要同时读取所有元素时，效率很高

#### 劣势：

​		如果要跳跃查找，效率很低。

#### 访问方式：

​		顺序访问

### 数组链表对比

|      | 数组 | 链表 |
| ---- | ---- | ---- |
| 读取 | O(1) | O(n) |
| 插入 | O(n) | O(1) |
| 删除 | O(n) | O(1) |

### 快速排序

分而治之(D&C)——一种著名的递归式问题解决方法。

#### （D&C）工作原理

1. 找出简单的基线条件；
2. 确定如何缩小问题的规模，使其符合基线条件。

### 散列表

将输入映射到数字，其实就是map数据。也称散列映射、映射、字典和关联数组。

应用示例：缓存。

|      | 数组 | 链表 | 散列表（平均情况） | 散列表（最糟情况） |
| ---- | ---- | ---- | ------------------ | ------------------ |
| 读取 | O(1) | O(n) | O(1)               | O(n)               |
| 插入 | O(n) | O(1) | O(1)               | O(n)               |
| 删除 | O(n) | O(1) | O(1)               | O(n)               |

散列表为了避开最糟情况需要避免冲突，为了避免冲突需要：

- 较低低填装因子（一旦填装因子大于0.7，就调整散列表的长度）；（填装因子：散列表包含的元素数/位置总数）
- 良好的散列函数。

### 广度优先搜索

解决最短路径问题的算法被称为广度优先搜索。(找出段数最少的路径)

#### 图

图模拟一组连接。由节点和边组成。

有向图：有指向他们的箭头，但没有从他们出发指向其他人的箭头。

无向图：没有箭头，直接相连的节点互为邻居。

拓扑图：如果任务A依赖于任务B，在列表中任务A就必须在任务B后面。

树：树是一种特殊的图，其中没有往后指的边。（如家谱）

### 狄克斯特拉算法

找出图中最便宜的节点，并确保没有到该节点的更便宜的路径（没有负权边）。

加权图：带权重的图

非加权图：不带权重的图

### 贪婪算法

每步都选择局部最优解，最终得到的就是全局最优解。