### 体系架构

Node.js主要分为四大部分，Node Standard Library，Node Bindings，V8，Libuv，架构图如下:

![a9e67142615f49863438cc0086b594e48984d1c9](../image/a9e67142615f49863438cc0086b594e48984d1c9.jpeg)

- Node Standard Library 是我们每天都在用的标准库，如Http, Buffer 模块。
- Node Bindings 是沟通JS 和 C++的桥梁，封装V8和Libuv的细节，向上层提供基础API服务。
- 这一层是支撑 Node.js 运行的关键，由 C/C++ 实现。
  - V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 Node.js 的发动机。
  - Libuv 是专门为Node.js开发的一个封装库，提供跨平台的异步I/O能力.
  - C-ares：提供了异步处理 DNS 相关的能力。
  - http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。

事件循环

- 1. **`timers` 阶段**: 这个阶段执行 `setTimeout(callback)` 和 `setInterval(callback)` 预定的 callback;
- 2. **`I/O callbacks` 阶段**: 此阶段执行某些系统操作的回调，例如TCP错误的类型。 例如，如果TCP套接字在尝试连接时收到 ECONNREFUSED，则某些* nix系统希望等待报告错误。 这将操作将等待在==I/O回调阶段==执行;
- 3. **`idle, prepare` 阶段**: 仅node内部使用;
- 4. **`poll` 阶段**: 获取新的I/O事件, 例如操作读取文件等等，适当的条件下node将阻塞在这里;
- 5. **`check` 阶段**: 执行 `setImmediate()` 设定的callbacks;
- 6. **`close callbacks` 阶段**: 比如 `socket.on(‘close’, callback)` 的callback会在这个阶段执行;

### libuv

libuv是一个跨平台的C库，用于异步I/O操作和事件循环。它的设计目标是提供高效的事件循环，以便应用程序能够在不同的操作系统上实现非阻塞I/O操作。

最初的node.js使用了Google的V8解析引擎和Marc Lehmann的libev。随着node.js的日益流行，node.js需要同时支持windows, 但是libev只能在Unix环境下运行。Windows 平台上与kqueue(FreeBSD)或者(e)poll(Linux)等内核事件通知相应的机制是IOCP。libuv提供了一个跨平台的抽象，由平台决定使用libev或IOCP。在node-v0.9.0版本中，libuv移除了libev的内容。

libuv的一些主要特点和功能：

1. **事件循环**：libuv提供了一个事件循环（Event Loop），用于处理异步事件，如文件I/O、网络通信和定时器。事件循环是许多异步操作的核心，它使应用程序能够同时处理多个任务而不阻塞。
2. **跨平台**：libuv被设计成跨平台的库，因此可以在不同的操作系统上运行，包括Windows、Linux、macOS等。这使得它成为了开发跨平台应用程序的有力工具。
3. **异步I/O**：libuv提供了一种异步的方式来执行I/O操作，允许应用程序在等待I/O完成的同时继续执行其他任务，从而提高了性能和响应性。
4. **定时器**：libuv支持定时器，允许您安排在未来的某个时间点执行特定的操作。
5. **线程池**：libuv还包含一个线程池，用于执行计算密集型的任务，以避免阻塞事件循环。
6. **事件处理**：libuv可以处理各种事件，包括文件I/O、套接字通信、信号处理等，这使得它非常适合构建网络应用程序和服务器。
7. **垃圾回收**：libuv包括对垃圾回收的支持，可以帮助管理内存。

### V8引擎

现在 JS 引擎的执行过程大致是：源代码 --->抽象语法树 --->字节码 --->JIT--->本地代码。

V8 更加直接的将抽象语法树通过 JIT 技术转换成本地代码，放弃了在字节码阶段可以进行的一些性能优化，但保证了执行速度。 在 V8 生成本地代码后，也会通过 Profiler 采集一些信息，来优化本地代码。虽然，少了生成字节码这一阶段的性能优化， 但极大减少了转换时间。

#### 垃圾回收

 V8 采用了标记指针法：这种方法需要在每个指针的末位预留一位来标记这个字代表的是指针或数据。

##### 1、对象的晋升

当一个对象经过多次新生代的清理依旧幸存，这说明它的生存周期较长，也就会被移动到老生代，这称为对象的晋升。具体移动的标准有两种：

- 对象从 From 空间复制到 To 空间时，会检查它的内存地址来判断这个对象是否已经活过一次新生代的清理，如果是，则复制到老生代中，否则复制到 To 空间中
- 对象从 From 空间复制到 To 空间时，如果 To 空间已经被使用了超过 25%，那么这个对象直接被复制到老生代。

##### 2、写屏障

如果新生区中某个对象，只有一个指向它的指针，而这个指针恰好是在老生区的对象当中，我们如何才能知道新生区中那个对象是活跃的呢？ 为了解决这个问题，实际上在写缓冲区中有一个列表 `store-buffer{.cc,.h,-inl.h}`，列表中记录了所有老生区对象指向新生区的情况。新对象诞生的时候，并不会有指向它的指针，而当有老生区中的对象出现指向新生区对象的指针时，我们便记录下来这样的跨区指向。由于这种记录行为总是发生在写操作时，它被称为写屏障.